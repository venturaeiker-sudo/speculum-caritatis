
import { useState, useEffect } from 'react';
import {
    collection,
    onSnapshot,
    addDoc as firestoreAddDoc,
    updateDoc as firestoreUpdateDoc,
    deleteDoc as firestoreDeleteDoc,
    doc,
    query,
    getDocs,
    writeBatch
} from 'firebase/firestore';
import { db } from '../firebase';

export const useFirestoreCollection = <T extends { id: string }>(collectionName: string) => {
    const [data, setData] = useState<T[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);

    useEffect(() => {
        setLoading(true);
        const q = query(collection(db, collectionName));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const results: T[] = [];
            snapshot.forEach((doc) => {
                results.push({ ...doc.data(), id: doc.id } as T);
            });
            setData(results);
            setLoading(false);
        }, (err) => {
            console.error(`Error fetching collection ${collectionName}:`, err);
            setError(err);
            setLoading(false);
        });

        return () => unsubscribe();
    }, [collectionName]);

    const add = async (item: Omit<T, 'id'> | T) => {
        try {
            // If item has an ID, use setDoc? No, let's treat ID as mainly auto-generated by Firestore 
            // OR if we want to preserve client-side IDs (which seems to be the case in this app like 'TX-123'),
            // we should use setDoc if ID is present, or addDoc if not.
            // But the app generates IDs like `TX-${Date.now()}`.
            // We can use that as the document ID.

            const itemWithId = item as T;
            if (itemWithId.id) {
                // Use the provided ID as the document ID
                const docRef = doc(db, collectionName, itemWithId.id);
                // @ts-ignore
                await import('firebase/firestore').then(mod => mod.setDoc(docRef, item));
            } else {
                await firestoreAddDoc(collection(db, collectionName), item);
            }
        } catch (err) {
            console.error(`Error adding to ${collectionName}:`, err);
            throw err;
        }
    };

    const update = async (id: string, fields: Partial<T>) => {
        try {
            const docRef = doc(db, collectionName, id);
            await firestoreUpdateDoc(docRef, fields as any);
        } catch (err) {
            console.error(`Error updating ${collectionName}:`, err);
            throw err;
        }
    };

    const remove = async (id: string) => {
        try {
            const docRef = doc(db, collectionName, id);
            await firestoreDeleteDoc(docRef);
        } catch (err) {
            console.error(`Error deleting from ${collectionName}:`, err);
            throw err;
        }
    };

    // Batch add for migration
    const batchAdd = async (items: T[]) => {
        if (items.length === 0) return;

        const batch = writeBatch(db);
        items.forEach(item => {
            const docRef = doc(db, collectionName, item.id);
            batch.set(docRef, item);
        });
        await batch.commit();
    }

    return { data, loading, error, add, update, remove, batchAdd };
};
